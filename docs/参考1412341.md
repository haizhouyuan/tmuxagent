yuanhaizhou@YogaS2:~/projects/tmuxagent-worktrees/fleetai$ . ~/.proxy-on.sh && proxychains4 -q codex --dangerously-bypass-approvals-and-sandbox
✅ 代理已启用
╭───────────────────────────────────────────────────╮
│ >_ OpenAI Codex (v0.41.0)                         │
│                                                   │
│ model:     gpt-5-codex high   /model to change    │
│ directory: ~/projects/tmuxagent-worktrees/fleetai │
╰───────────────────────────────────────────────────╯

  To get started, describe a task or try one of these commands:

  /init - create an AGENTS.md file with instructions for Codex
  /status - show current session configuration
  /approvals - choose what Codex can do without approval
  /model - choose what model and reasoning effort to use

▌ '/home/yuanhaizhou/projects/tmuxagent-worktrees/fleetai/docs/凭证.md'
yuanhaizhou@YogaS2:~/projects/tmuxagent-worktrees/fleetai$ claude --dangerously-skip-permissions

🌟 Welcome to Claude Code!
🔗 You are using the canonical relay
💡 If the relay doesn't work, you can run `claude --pick-relay`


══════════════════════════════════════════════════════════════════════
📢 ANNOUNCEMENTS
══════════════════════════════════════════════════════════════════════

ℹ️ Codex已上线本站
──────────────────────────────────────────────────
Codex已上线本站,通过控制台命令即可安装配置并使用,目前codex智商在线,无需额外订阅即可畅享,本站Codex均采用官方正版200美刀订阅类型,欢迎大家前来测试体验!

══════════════════════════════════════════════════════════════════════
📝 Press Enter to continue...

 
 ✻ Welcome to Claude Code!

   /help for help, /status for your current setup

   cwd: /home/yuanhaizhou/projects/tmuxagent-worktrees/fleetai

 Tips for getting started:

  Run /init to create a CLAUDE.md file with instructions for 
  Claude
  Run /terminal-setup to set up terminal integration
  Use Claude to help with file analysis, editing, bash commands 
  and git
  Be as specific as you would with another engineer for the best 
  results

> > 变更说明
                                                             
      y.py,
    - 在 src/tmux_agent/notify.py 
  增加企业微信“应用消息”通道：读
    取 
  WECOM_CORP_ID、WECOM_AGENT_ID、WECOM_APP_SECRET，自动缓存 
  to
    access_token，统一以 Markdown 发送内容，可选 
  WECOM_TOUSER（默or认为                                     
                        repare
    @all）、WECOM_TOPARTY、WECOM_TOTAG。                     
      eps.
    - 新增 tests/test_notify.py，覆盖环境变量缺失、获取 token
   失
  败、发
    送成功并命中缓存等场景，确保逻辑稳定。
    - README 新增“通知通道”小节，说明 wecom_app 
  及所需环境变量，
  方便直
    接套用 docs/凭证.md 里的企业微信凭证。                   
      认为

    如何使用                                                 
       、发

    1. 在 agents 配置里把 notify 设置为 wecom_app。          
       便直
    2. 导出凭证：

       export WECOM_CORP_ID=ww963453c57ce43b45
       export WECOM_AGENT_ID=1000002
       export WECOM_APP_SECRET=eu-
    BbKawabreQTJPeacL63jVYllSJILrDVMHIjiTs2A
       export WECOM_TOUSER=xxxx  # 可选，不设默认 @all
    3. 启动调度器后，所有 policy 
  触发的通知都会直接推送给企业微信应用；
    token 会自动续期。

    已执行测试
                                                             
      应用；
    - .venv/bin/python -m pytest按照这个执行

● I'll run the tests as requested to verify the WeChat Work
   (企业微信) notification channel implementation.

● Bash(.venv/bin/python -m pytest tests/test_notify.py -v)
  ⎿ ============================= test session starts ====
    ==========================
    platform linux -- Python 3.11.2, pytest-8.4.2, pluggy-
    … +83 lines (ctrl+o to expand)



● The tests passed successfully! All 3 test cases for the
  WeChat Work notification integration are working
  correctly:

  - ✅ test_wecom_app_missing_env - Handles missing
  environment variables properly
  - ✅ test_wecom_app_token_error - Handles token retrieval
   errors correctly
  - ✅ test_wecom_app_send_success_with_caching - Sends
  messages successfully and caches tokens

  The implementation covers the key scenarios mentioned in
  your change description:
  1. Environment variable validation
  2. Token caching and automatic renewal
  3. Message sending with proper error handling

  The tests show 69% coverage for src/tmux_agent/notify.py,
   which indicates good test coverage for the new WeChat
  Work functionality.

> 发到哪里了

● Looking at the test results, the WeChat Work
  notifications are being sent to a mock/test environment
  during testing. Let me check the actual notification
  configuration to see where messages would be sent in real
   usage.

● Read(tests/test_notify.py)
  ⎿  Read 134 lines (ctrl+o to expand)

● 测试是发到模拟环境的。在实际使用时，根据你的配置说明，消
  息会发到：

  企业微信应用 ID 1000002，属于企业 ww963453c57ce43b45

  发送目标根据环境变量确定：
  - WECOM_TOUSER=xiaozhang|xiaoli - 发给指定用户
  - 如果未设置 WECOM_TOUSER - 默认发给 @all（全员）
  - 也可设置 WECOM_TOPARTY 或 WECOM_TOTAG
  发给特定部门或标签

  测试中使用的是假数据，真实环境需要你配置的企业微信凭证。

> 你给我配置好，我要发到我的企业微信上

● 我需要先查看现有的配置文件和环境设置方式，然后帮你配置企
  业微信通知。

● Read(docs/凭证.md)
  ⎿  Read 9 lines (ctrl+o to expand)

● Search(pattern: "**/.env*")
  ⎿  Found 0 files 

● Search(pattern: "**/config*")
  ⎿  Found 6 files (ctrl+o to expand)

● Read(src/tmux_agent/config.py)
  ⎿  Read 163 lines (ctrl+o to expand)

● 现在我帮你配置企业微信通知。根据你的凭证文档，我会创建环
  境变量配置：

● Write(.env)
  ⎿  Wrote 10 lines to .env                               
     # 企业微信应用消息配置
     WECOM_CORP_ID=ww963453c57ce43b45
     WECOM_AGENT_ID=1000002
     WECOM_APP_SECRET=eu-BbKawabreQTJPeacL63jVYllSJILrDVMHI
     jiTs2A
     # 消息接收者设置（可选）
     # WECOM_TOUSER=@all  # 默认发送给所有人
     # WECOM_TOUSER=xiaozhang|xiaoli  # 发送给指定用户
     # WECOM_TOPARTY=部门ID  # 发送给指定部门
     # WECOM_TOTAG=标签ID  # 发送给指定标签

● 现在需要在你的配置文件中设置通知通道为
  wecom_app。让我查看是否已有配置文件：

● Bash(find . -name "*.yaml" -o -name "*.yml" | head -10)
  ⎿ ./examples/policy.example.yaml                        
    ./examples/hosts.example.yaml
    ./.tmuxagent/worktrees/agent-mvp/examples/policy.examp
    … +3 lines (ctrl+o to expand)


● Read(examples/hosts.example.yaml)
  ⎿  Read 30 lines (ctrl+o to expand)

● 我创建一个配置文件，将通知通道设置为企业微信：

● Write(agent-config.yaml)
  ⎿  Wrote 14 lines to agent-config.yaml    
     poll_interval_ms: 1500
     tmux_bin: tmux
     sqlite_path: ~/.tmux_agent/state.db
     approval_dir: ~/.tmux_agent/approvals
     notify: wecom_app  # 设置为企业微信通知
     hosts:
       - name: local
         tmux:
           socket: default
           session_filters: []
     … +4 lines (ctrl+o to expand)

● 现在创建一个测试脚本来验证配置：

● Write(test_wecom.py)
  ⎿  Wrote 43 lines to test_wecom.py             
     #!/usr/bin/env python3
     """测试企业微信通知配置"""
     import os
     from dotenv import load_dotenv
     from src.tmux_agent.notify import Notifier,
     NotificationMessage
     # 加载环境变量
     load_dotenv()
     def test_wecom_notification():
     … +33 lines (ctrl+o to expand)

● 现在测试配置：

● Bash(.venv/bin/python test_wecom.py)
  ⎿  Error: ✅ 环境变量检查通过
     📤 正在发送测试消息到企业微信...
     ❌ 发送失败: Using SOCKS proxy, but the 'socksio' package 
     is not installed. Make sure to install httpx using `pip 
     install httpx[socks]`.

● 需要安装 dotenv 和处理代理问题：

● Bash(.venv/bin/pip install python-dotenv)
  ⎿ Requirement already satisfied: python-dotenv in ./.ven
    v/lib/python3.11/site-packages (1.1.1)


● Bash(unset HTTP_PROXY HTTPS_PROXY http_proxy https_proxy &&
      .venv/bin/python test_wecom.py)
  ⎿  Error: ✅ 环境变量检查通过
     📤 正在发送测试消息到企业微信...
     ❌ 发送失败: Using SOCKS proxy, but the 'socksio' package 
     is not installed. Make sure to install httpx using `pip 
     install httpx[socks]`.

● 让我检查环境中的代理设置：

● Bash(env | grep -i proxy)
  ⎿  no_proxy=localhost,127.0.0.1,::1 
     https_proxy=http://127.0.0.1:7890
     NO_PROXY=localhost,127.0.0.1,::1
     … +4 lines (ctrl+o to expand)

● 需要安装 socks 支持或修改测试脚本临时禁用代理：

● Update(test_wecom.py)
  ⎿  Updated test_wecom.py with 8 additions             
        7    # 加载环境变量
        8    load_dotenv()
        9    
       10 +  # 临时禁用代理设置
       11 +  proxy_vars = ['http_proxy', 'https_proxy', 
          + 'HTTP_PROXY', 'HTTPS_PROXY', 'all_proxy']
       12 +  original_proxies = {}
       13 +  for var in proxy_vars:
       14 +      if var in os.environ:
       15 +          original_proxies[var] = 
          + os.environ[var]
       16 +          del os.environ[var]
       17 +  
       18    def test_wecom_notification():
       19        """测试企业微信通知发送"""
       20        # 检查必需的环境变量

● Bash(.venv/bin/python test_wecom.py)
  ⎿  Error: ✅ 环境变量检查通过
     📤 正在发送测试消息到企业微信...
     ❌ 发送失败: WeCom send message failed: {'errcode': 60020, 
     'errmsg': 'not allow to access from your ip, hint: 
     [1758794086107082606871475], from ip: 122.231.213.137, more
      info at 
     https://open.work.weixin.qq.com/devtool/query?e=60020'}

● IP 受限问题。这是企业微信的安全设置，需要在企业微信管理后
  台配置可信IP。现在配置已经完成，我来总结一下：

● ✅ 企业微信通知已配置完成！

  已完成的配置：

  1. 环境变量文件 (.env):
  WECOM_CORP_ID=ww963453c57ce43b45
  WECOM_AGENT_ID=1000002
  WECOM_APP_SECRET=eu-BbKawabreQTJPeacL63jVYllSJILrDVMHIjiT
  s2A
  2. 代理配置文件 (agent-config.yaml):
  notify: wecom_app  # 设置通知通道为企业微信

  ⚠️ 需要解决IP白名单问题：

  测试显示错误码 60020，表示当前IP 122.231.213.137
  不在企业微信应用的可信IP列表中。

  解决方法：
  1. 登录 https://work.weixin.qq.com/
  2. 进入"应用管理" → 找到你的应用（ID: 1000002）
  3. 在"网络配置"或"IP白名单"中添加当前IP: 122.231.213.137

  使用方法：
  # 加载环境变量并启动代理
  source .env
  # 运行你的 tmux-agent，所有通知都会发到企业微信

  配置无误，只需添加IP白名单即可正常使用！
  
  chatgpt:
  
  好的，我来把“企业微信应用消息（WeCom App）”通知通道从**代码到环境到网络**一步到位给你配好，并把你现在遇到的 `errcode 60020 (not allow to access from your ip)` 彻底解决。以下内容你可以**原样拷到命令行/配置文件**里用。

---

# 一、先说结论（你现在的阻塞点）

* 你的测试已走到“真实联通企业微信 API”的阶段，但被**企业微信接口 IP 白名单**拦住了：
  `not allow to access from your ip ... from ip: 122.231.213.137`
* 这个 `122.231.213.137` 是你当前**实际对外出口 IP**（很可能是代理/家宽NAT出口），需要把它加入**企业微信管理后台 → 自建应用的“可信IP/接口IP白名单”**。
* 你环境里有 `proxychains4 / HTTP(S)_PROXY` 等代理设置；若继续走代理，**被白名单放行的就必须是代理的出口 IP**；如果你改为直连，必须把**本机的公网出口 IP**加入白名单。

> 建议路线（稳定 & 可维护）
> **选一个有固定公网IP的主机（如你的 NAS、阿里云ECS）作为“通知出口”**：
>
> 1. 在企业微信后台把这台机器的公网IP加入白名单；
> 2. 保证所有到 `qyapi.weixin.qq.com` 的调用都从这台机器直连发出（不经代理）。
>    这样最稳，后续不会因为代理IP变化而频繁改白名单。

---

# 二、最小可用配置（本地验证步骤）

## 1. 依赖与环境准备

```bash
# 进入 venv
source .venv/bin/activate

# 安装 httpx 的 socks 扩展（你之前的错误提示需要它）
pip install "httpx[socks]" python-dotenv
```

> 如果你最终选择**对企业微信直连**，也可以不需要 socks 支持，但为了你平时其它流量还走代理，建议装上，保持灵活。

## 2. 敏感信息与 .env（注意不要泄露！）

你仓库里的 `.env` 请这样写（别再明文贴到聊天/PR里）：

```dotenv
# 企业微信应用消息配置（示例：请自行替换真实值）
WECOM_CORP_ID=ww963453c57ce43b45
WECOM_AGENT_ID=1000002
WECOM_APP_SECRET=***REDACTED***   # 别再明文对外
# 可选的接收范围（择一或都不填）
# WECOM_TOUSER=@all
# WECOM_TOUSER=xiaozhang|xiaoli
# WECOM_TOPARTY=2|5
# WECOM_TOTAG=3
```

权限加固（避免误泄）：

```bash
chmod 600 .env
git update-index --assume-unchanged .env
```

## 3. 代理策略（强烈推荐：对 qyapi 直连）

目标：企业微信 API 走直连，其它依旧走代理。

### 方案 A：通过环境变量排除（最简单）

```bash
# 在当前 shell 会话里，仅对 wecom 相关域名禁用代理：
export NO_PROXY="localhost,127.0.0.1,::1,qyapi.weixin.qq.com,open.work.weixin.qq.com"
export no_proxy="$NO_PROXY"
```

> 说明：`qyapi.weixin.qq.com` 是主要接口域名；`open.work.weixin.qq.com` 用于调试页面，不一定调用，但加上无害。

### 方案 B：代码内强制直连（对 httpx 客户端设定）

如果你在 `src/tmux_agent/notify.py` 用 `httpx`，可以在创建客户端时强制忽略系统代理：

```python
import httpx

client = httpx.Client(
    base_url="https://qyapi.weixin.qq.com",
    timeout=10.0,
    trust_env=False,      # 不继承环境变量里的代理
    proxies=None          # 明确不使用代理
)
```

> 推荐在**仅企业微信的客户端**上设此项，避免影响其它需要代理的请求。

---

# 三、企业微信后台：把“实际出口IP”加入白名单

> 后台入口在不同版本里名称略有差异，常见两处：
>
> * **应用管理 → 你创建的自建应用 → 开发管理 → 接口IP白名单 / 可信IP**
> * 或 **管理工具 → 安全与保密 → 接口IP白名单**

需要加入的就是**调用时显示的 from ip**。你日志里是：

```
from ip: 122.231.213.137
```

> 如果你改为直连，这个IP会变成你的主机公网IP。
> 如果你走代理，这个是**代理的出口IP**，那就应该把**代理出口**加入白名单。

### 快速查“当前将要被企业微信看到的出口IP”

* 走代理情况下（模拟真实调用路径）：

  ```bash
  # 如果你用 proxychains4：
  proxychains4 -q curl -s https://ipinfo.io/ip
  ```
* 直连情况下：

  ```bash
  curl -s https://ipinfo.io/ip
  # 或
  dig +short TXT o-o.myaddr.l.google.com @ns1.google.com | tr -d '"'
  ```

> 把得到的 IP 填进白名单；如果你有多条出口（家宽+代理+云主机），**全都加上**。

---

# 四、发送“真实”联通测试（绕过你先前的 test\_wecom.py 限制）

我给你一个**独立的最小发送脚本**（只依赖 `.env`，并且对 WeCom 强制直连），你直接跑它确认“白名单+连通”OK：

```python
# file: scripts/wecom_smoke_test.py
import os, sys, json, time
from dotenv import load_dotenv
import httpx

def must_get(name: str) -> str:
    v = os.getenv(name)
    if not v:
        print(f"[FAIL] missing env: {name}", file=sys.stderr)
        sys.exit(2)
    return v

def main():
    load_dotenv()
    corp_id = must_get("WECOM_CORP_ID")
    agent_id = must_get("WECOM_AGENT_ID")
    secret  = must_get("WECOM_APP_SECRET")
    touser  = os.getenv("WECOM_TOUSER", "@all")
    toparty = os.getenv("WECOM_TOPARTY")
    totag   = os.getenv("WECOM_TOTAG")

    # 强制直连，不走代理
    with httpx.Client(trust_env=False, proxies=None, timeout=10.0) as c:
        # 1) gettoken
        r = c.get("https://qyapi.weixin.qq.com/cgi-bin/gettoken",
                  params={"corpid": corp_id, "corpsecret": secret})
        data = r.json()
        if data.get("errcode") != 0:
            print("[FAIL] gettoken:", data, file=sys.stderr)
            sys.exit(3)
        token = data["access_token"]
        # 2) send message (Markdown)
        url = "https://qyapi.weixin.qq.com/cgi-bin/message/send"
        payload = {
            "touser": touser,
            "agentid": int(agent_id),
            "msgtype": "markdown",
            "markdown": {"content": f"**WeCom Smoke Test**\n> {time.ctime()} 来自 tmux-agent"},
            "duplicate_check_interval": 600,
        }
        if toparty: payload["toparty"] = toparty
        if totag:   payload["totag"]   = totag
        r2 = c.post(url, params={"access_token": token}, json=payload)
        d2 = r2.json()
        if d2.get("errcode") == 0:
            print("[OK] message sent:", json.dumps(d2, ensure_ascii=False))
            sys.exit(0)
        else:
            print("[FAIL] send:", d2, file=sys.stderr)
            sys.exit(4)

if __name__ == "__main__":
    main()
```

运行：

```bash
python scripts/wecom_smoke_test.py
```

**期望结果：**

* 如果白名单未配、或走了未放行的出口IP → 仍会报 60020
* 白名单配置正确 → 输出 `[OK] message sent: {"errcode":0,...}`，手机端企业微信能收到

---

# 五、把通知通道接入你的 tmux-agent

你已经有 `agent-config.yaml`：

```yaml
poll_interval_ms: 1500
tmux_bin: tmux
sqlite_path: ~/.tmux_agent/state.db
approval_dir: ~/.tmux_agent/approvals
notify: wecom_app   # 使用企业微信应用消息
hosts:
  - name: local
    tmux:
      socket: default
      session_filters: []
```

> 确保 `src/tmux_agent/notify.py` 的 `wecom_app` 实现里：
>
> * token 有**文件缓存**（建议落到 `~/.tmux_agent/wecom_token.json`），至少包含 `access_token`、`expires_at`（UNIX ts），临近过期自动刷新；
> * HTTP 客户端针对 WeCom 强制 `trust_env=False, proxies=None` 或按你的策略注入 `NO_PROXY`。

**推荐的 token 缓存片段（伪代码）**：

```python
import json, time, os, httpx, threading
CACHE_PATH = os.path.expanduser("~/.tmux_agent/wecom_token.json")
LOCK = threading.Lock()

def _load_cache():
    try:
        with open(CACHE_PATH, "r") as f:
            return json.load(f)
    except:
        return {}

def _save_cache(data):
    os.makedirs(os.path.dirname(CACHE_PATH), exist_ok=True)
    tmp = CACHE_PATH + ".tmp"
    with open(tmp, "w") as f:
        json.dump(data, f)
    os.replace(tmp, CACHE_PATH)

def get_access_token(corp_id, secret):
    with LOCK:
        cache = _load_cache()
        now = int(time.time())
        if cache.get("access_token") and cache.get("expires_at", 0) - now > 180:
            return cache["access_token"]
        with httpx.Client(trust_env=False, proxies=None, timeout=10.0) as c:
            r = c.get("https://qyapi.weixin.qq.com/cgi-bin/gettoken",
                      params={"corpid": corp_id, "corpsecret": secret})
            data = r.json()
            if data.get("errcode") != 0:
                raise RuntimeError(f"WeCom token error: {data}")
            token = data["access_token"]
            # 官方给的 expires_in 一般 7200 秒
            expires_at = now + int(data.get("expires_in", 7200))
            cache = {"access_token": token, "expires_at": expires_at}
            _save_cache(cache)
            return token
```

---

# 六、系统服务化（可选，但推荐）

如果你把 `tmux-agent` 作为 systemd 用户服务跑，需要把 `.env` 注入环境并**确保 NO\_PROXY 生效**：

`~/.config/systemd/user/tmux-agent.service`（示例）：

```ini
[Unit]
Description=Tmux Agent with WeCom Notify

[Service]
Type=simple
WorkingDirectory=%h/projects/tmuxagent-worktrees/fleetai
EnvironmentFile=%h/projects/tmuxagent-worktrees/fleetai/.env
# 对企业微信直连
Environment=NO_PROXY=localhost,127.0.0.1,::1,qyapi.weixin.qq.com,open.work.weixin.qq.com
Environment=no_proxy=localhost,127.0.0.1,::1,qyapi.weixin.qq.com,open.work.weixin.qq.com
ExecStart=%h/projects/tmuxagent-worktrees/fleetai/.venv/bin/python -m src.tmux_agent.run --config %h/projects/tmuxagent-worktrees/fleetai/agent-config.yaml
Restart=always

[Install]
WantedBy=default.target
```

启用：

```bash
systemctl --user daemon-reload
systemctl --user enable --now tmux-agent
systemctl --user status tmux-agent --no-pager
```

---

# 七、GitHub Actions/CI 里发企业微信（可选）

把下面几个 Secrets 配进去：`WECOM_CORP_ID` `WECOM_AGENT_ID` `WECOM_APP_SECRET` `WECOM_TOUSER`（可选）。
**注意：Runner 的出口 IP 也要在白名单里**（GitHub 托管 Runner IP 变化大，不推荐；可用自托管 Runner）。

示例 Job 步骤（Python）：

```yaml
- name: Send WeCom notify
  if: always()
  env:
    WECOM_CORP_ID: ${{ secrets.WECOM_CORP_ID }}
    WECOM_AGENT_ID: ${{ secrets.WECOM_AGENT_ID }}
    WECOM_APP_SECRET: ${{ secrets.WECOM_APP_SECRET }}
    WECOM_TOUSER: ${{ secrets.WECOM_TOUSER }}
    NO_PROXY: "qyapi.weixin.qq.com,open.work.weixin.qq.com,127.0.0.1,localhost,::1"
  run: |
    python - <<'PY'
    import os, httpx, time
    corp = os.environ["WECOM_CORP_ID"]
    agent = os.environ["WECOM_AGENT_ID"]
    secret= os.environ["WECOM_APP_SECRET"]
    touser= os.environ.get("WECOM_TOUSER","@all")
    with httpx.Client(trust_env=False, proxies=None, timeout=10.0) as c:
        t = c.get("https://qyapi.weixin.qq.com/cgi-bin/gettoken",
                  params={"corpid": corp, "corpsecret": secret}).json()
        if t.get("errcode")!=0: raise SystemExit(t)
        r = c.post("https://qyapi.weixin.qq.com/cgi-bin/message/send",
                   params={"access_token": t["access_token"]},
                   json={"touser": touser, "agentid": int(agent),
                         "msgtype":"markdown",
                         "markdown":{"content": f"**CI通知**\n> {time.ctime()}"},
                         "duplicate_check_interval":600}).json()
        if r.get("errcode")!=0: raise SystemExit(r)
    PY
```

---

# 八、常见错误一览（对照排障）

| errcode | 含义/典型原因               | 解决                                       |
| ------- | --------------------- | ---------------------------------------- |
| 60020   | 不在可信IP/接口白名单          | 把**实际出口IP**加白（代理出口或直连出口），多出口都加           |
| 40014   | invalid access\_token | 刷新 token；检查 corp\_id/secret；避免复用过期 token |
| 42001   | access\_token expired | 同上，重新获取；实现本地缓存并自动更新                      |
| 40003   | invalid openid        | `touser` 填写错误；确认成员在企业内且已分配到此应用可见范围       |
| 81013   | user not in app       | 用户不在该“自建应用”的可见范围；到应用可见范围里添加              |
| 45009   | 接口调用超上限               | 降频、合并消息，或延迟发送                            |
| 41001   | 缺少 access\_token 参数   | URL 漏了 `?access_token=`；或 POST 错路径       |

---

# 九、如果你不想折腾白名单：两种替代路径

1. **企业微信群机器人（Webhook）**

   * 只要在群里加“群机器人”，就能直接用 webhook URL 发 Markdown，无需白名单；
   * 缺点：发到“群”，非“应用消息”；安全上要小心外泄 webhook。

2. **固定出口中转（反向代理）**

   * 在你有固定IP的云主机上起一个**极简转发 API**（FastAPI/Nginx），内部把请求转给 `qyapi.weixin.qq.com`；
   * 企业微信白名单里只加这个云主机IP；业务端把 WeCom 请求都打到这个中转即可。
   * 缺点：你要维护一个中转服务（可以 50 行代码搞定）。

---

# 十、你现在要做的最小动作清单 ✅

1. **确定出口路径**：决定企业微信 API 是**直连**还是**走代理**。
2. **查出口 IP**（按上面命令）并**加入企业微信白名单**。
3. **设置 NO\_PROXY** 或在代码里对 WeCom 客户端 `trust_env=False, proxies=None`。
4. 运行 `python scripts/wecom_smoke_test.py`：看到 `[OK] message sent` 即打通。
5. 启动 `tmux-agent`，触发一条通知（比如手工触发 policy），验证手机端能收到。

---

需要我把你 `src/tmux_agent/notify.py` 的 WeCom 客户端部分**改成可直连/可代理二选一、带文件级 token 缓存**的完整补丁吗？我可以直接给出**可粘贴的 diff**。另外，如果你选择“云主机中转”方案，我也可以给你一份**FastAPI 反代到 qyapi**的最小实现（含 systemd 与 Nginx 配置）。
