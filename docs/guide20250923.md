好的，基于你现在**最多 3–5 个 tmux session**、两个项目（**storyapp** 与 **points**），以及**不想在提效工程上投入太多精力**的诉求，我给你一条**快速起飞的实现路线（路线 A）**和一套**可直接粘贴给 codex cli 开发的代码实现方案**。目标是：**用最少的依赖**在 NAS 上跑一个“调度+监控”Agent，自动读取 tmux 窗口输出、总结、按规则驱动下一步、需要你裁决时自动停住并提醒；你给出决策后继续推进，并做简要复盘。

> 我已为你生成了一个可运行的骨架项目（MVP），包含 SSH/tmux 封装、增量抓取、规则引擎、自动 `send-keys`、通知适配器占位、tmux 启动脚本等。
> **下载：**[tmux\_sentry\_mvp.zip](sandbox:/mnt/data/tmux_sentry_mvp.zip)

---

## 一、路线选型（**路线 A：纯 tmux + 轻量 Python 调度器**）

* **不引入 Redis/NATS**，全部组件在 NAS 本机；
* 通过 SSH 调用 `tmux list-*/capture-pane/send-keys` 完成会话发现、增量抓取、动作注入；
* **用 YAML 策略**描述开发流程（lint → test → build → deploy…）与触发/成功/失败/审批点；
* **通知**先走最简（stdout 或 Server酱，可后续换企业微信机器人）；
* **HITL 审批**采用“**文件式回执**”（极简可用）：需要你确认时会提示一个本地文件路径；你 `echo approve > 文件` 即可解锁继续。

这条路线**足够覆盖你现在的 2 个项目与几个 codex cli 并行**，实现成本低、上线快，后续要增强再演进（比如接入企业微信回调、引入 Redis 队列等）。

---

## 二、tmux 命名与窗口规划（建议）

为便于策略匹配与监控，统一命名（可以用你的原有 session 改个名）：

* **会话（session）**：`proj:storyapp`、`proj:points`
* **窗口（window）**（每个能力一个窗口）：

  * storyapp：`agent:codex-ci`、`agent:codex-ux`、`agent:codex-voice`
  * points：`agent:codex-ux`、`agent:codex-release`
* **pane 标题（pane title）**：`codex:ci`、`codex:ux`、`codex:voice`、`codex:release` …

> 这样调度器可以只靠 `window_name`/`pane_title` 正则就分辨出是谁。

---

## 三、快速上手步骤（最少工作量）

1. **下载骨架并安装依赖**

```bash
python -m venv .venv && source .venv/bin/activate
pip install -r requirements.txt
```

2. **配置主机**（把示例复制为你的）

```bash
cp hosts.example.yaml hosts.yaml
```

**示例 `hosts.yaml`（按你 NAS 修改）**：

```yaml
hosts:
  - name: nas
    ssh:
      host: 192.168.1.50      # 你的 NAS IP
      port: 22
      user: nasuser
      key: /home/nasuser/.ssh/id_rsa
    tmux:
      socket: default
      session_filters:    # 只看这两个项目
        - "^proj:storyapp$"
        - "^proj:points$"
      pane_name_patterns: # 识别“智能体”pane
        - "^codex"
        - "^claude"
      capture_lines: 2000
      poll_interval_ms: 1500
```

3. **按你的流程定义策略**
   把下面给你的 `policies/default.yaml` 覆盖项目里的同名文件（已针对 **storyapp** 与 **points** 的现状定制了 3 条流水线）。

4. **（可选）通知渠道**
   默认 `stdout`。如果你想手机收到消息，最简先用 **Server酱**：

```bash
cp .env.example .env
# .env 里填 SENTRY_SERVERCHAN_KEY=your_key
export SENTRY_NOTIFY_CHANNEL=serverchan
```

（后续要换企业微信机器人很容易，加一个 webhook 适配即可。）

5. **运行**

```bash
python -m tmux_sentry.main --config hosts.yaml --policy policies/default.yaml
```

它会：**发现 pane → 增量读输出 → 识别/总结 → 按策略 `send-keys` 驱动下一步 → 需要审批则停住并提示审批文件路径**。

6. **你平时做两件事**

* 在各窗口里让 `codexcli` 工作（见下面“给 codex/claude 的约定”）；
* 偶尔被询问审批时，执行：

  ```bash
  echo approve > ~/.tmux_sentry/approvals/<文件名>.txt   # 通过
  # 或
  echo reject  > ~/.tmux_sentry/approvals/<文件名>.txt   # 拒绝
  ```

---

## 四、给 codex/claude 的约定（便于机器解析）

在每个 codex/claude 的**首条提示**里加上这段“系统规则”，让它在关键节点输出**可机器解析**的标记行（不影响日常自然输出）：

> 当你完成一个阶段或需要人类批准/选择时，请额外打印一行：
> `### SENTRY {JSON}`
> 其中 JSON 形如：
>
> * `{"type":"STATUS","stage":"lint","ok":true,"summary":"0 problems"}`
> * `{"type":"ASK","stage":"build","question":"是否继续构建？","options":["yes","no"]}`
> * `{"type":"ERROR","stage":"test","detail":"2 failing"}`
>   其他输出照常即可。

骨架的解析器已支持识别 `### SENTRY {...}` 与常见错误/成功关键字。

---

## 五、策略文件（直接可用，按需改路径/日志特征）

将以下内容保存为 `policies/default.yaml`（覆盖骨架里的）：

```yaml
principles:
  - "能自动就自动；遇到风险点（构建/部署）要人工批准"
  - "失败先自愈：重试一次，仍失败再询问/升级"
  - "每步记录要点，便于复盘"

pipelines:
  # 1) storyapp 的 CI/CD 流水线（在窗口 agent:codex-ci）
  - name: "storyapp-ci"
    match:
      any_of:
        - window_name: "^agent:codex-ci$"
    stages:
      - name: "lint"
        triggers:
          any_of:
            - log_regex: "(?i)npm run lint"
            - log_regex: "### SENTRY .*\"stage\"\\s*:\\s*\"lint\""
        actions_on_start:
          - send_keys: "npm run lint"
        success_when:
          any_of:
            - log_regex: "(?i)0 problems?"
            - log_regex: "### SENTRY .*\"type\"\\s*:\\s*\"STATUS\".*\"stage\"\\s*:\\s*\"lint\".*\"ok\"\\s*:\\s*true"
        fail_when:
          any_of:
            - log_regex: "(?i)✖ .* problems?"
            - log_regex: "(?i)error.*eslint"
        on_fail:
          - retry: { max: 1, backoff_ms: 2000 }
          - if_still_fail: { ask_human: "Lint 失败，是否尝试自动修复并继续？(approve/reject)" }

      - name: "test"
        triggers:
          - after_stage_success: "lint"
        actions_on_start:
          - send_keys: "npm test -- --reporter=line"
        success_when:
          any_of:
            - log_regex: "(?i)\\b(\\d+)\\s+passing\\b"
            - log_regex: "### SENTRY .*\"stage\"\\s*:\\s*\"test\".*\"ok\"\\s*:\\s*true"
        fail_when:
          - log_regex: "(?i)\\b(\\d+)\\s+failing\\b"
        on_fail:
          - retry: { max: 1, backoff_ms: 3000 }
          - if_still_fail: { ask_human: "单测失败，是否继续构建？(approve/reject)" }

      - name: "build"
        triggers:
          - after_stage_success: "test"
        require_approval: true
        actions_on_start:
          - send_keys: "npm run build"
        success_when:
          any_of:
            - log_regex: "(?i)Built successfully|Compiled successfully"
            - log_regex: "### SENTRY .*\"stage\"\\s*:\\s*\"build\".*\"ok\"\\s*:\\s*true"
        on_fail:
          - escalate: "storyapp_build_failed"

      - name: "deploy:staging"
        triggers:
          - after_stage_success: "build"
        actions_on_start:
          - send_keys: "gh workflow run deploy-staging.yml --ref $(git rev-parse --abbrev-ref HEAD)"
        success_when:
          any_of:
            - log_regex: "(?i)workflow run started"
            - log_regex: "(?i)Deployed to staging"
        on_fail:
          - escalate: "storyapp_staging_deploy_failed"

  # 2) storyapp 的语音功能开发（窗口 agent:codex-voice）
  - name: "storyapp-voice"
    match:
      any_of:
        - window_name: "^agent:codex-voice$"
    stages:
      - name: "voice-e2e"
        triggers:
          any_of:
            - log_regex: "### SENTRY .*\"stage\"\\s*:\\s*\"voice-e2e\""
            - log_regex: "(?i)run voice e2e"
        actions_on_start:
          - send_keys: "npm run test:voice"
        success_when:
          any_of:
            - log_regex: "(?i)\\b(\\d+)\\s+passing\\b"
            - log_regex: "### SENTRY .*\"stage\"\\s*:\\s*\"voice-e2e\".*\"ok\"\\s*:\\s*true"
        fail_when:
          - log_regex: "(?i)\\b(\\d+)\\s+failing\\b"
        on_fail:
          - retry: { max: 1, backoff_ms: 3000 }
          - if_still_fail: { ask_human: "语音用例失败，是否清缓存重跑？(approve/reject)" }

  # 3) points 的上线前准备（窗口 agent:codex-release）
  - name: "points-release"
    match:
      any_of:
        - window_name: "^agent:codex-release$"
    stages:
      - name: "ux-check"
        triggers:
          any_of:
            - log_regex: "(?i)ux check"
            - log_regex: "### SENTRY .*\"stage\"\\s*:\\s*\"ux-check\""
        actions_on_start:
          - send_keys: "npm run lint && npm test -- --reporter=line"
        success_when:
          any_of:
            - log_regex: "(?i)0 problems?"
            - log_regex: "(?i)\\b(\\d+)\\s+passing\\b"
        fail_when:
          any_of:
            - log_regex: "(?i)✖ .* problems?"
            - log_regex: "(?i)\\b(\\d+)\\s+failing\\b"
        on_fail:
          - ask_human: "points UX 校验失败，是否允许跳过进入构建？(approve/reject)"

      - name: "prebuild"
        triggers:
          - after_stage_success: "ux-check"
        actions_on_start:
          - send_keys: "npm run build"
        success_when:
          any_of:
            - log_regex: "(?i)Built successfully|Compiled successfully"
        on_fail:
          - retry: { max: 1, backoff_ms: 2000 }
          - if_still_fail: { escalate: "points_prebuild_failed" }

      - name: "predeploy"
        triggers:
          - after_stage_success: "prebuild"
        require_approval: true
        actions_on_start:
          - send_keys: "./scripts/predeploy.sh"
        success_when:
          any_of:
            - log_regex: "(?i)predeploy done|ready for prod"
        on_fail:
          - escalate: "points_predeploy_failed"
```

> 逻辑要点：
>
> * **匹配**靠窗口名 `agent:codex-*`；
> * **触发**靠日志关键字或 `### SENTRY` JSON；
> * **危险动作**（构建/部署）标记 `require_approval: true`；
> * **失败**先重试，再询问/升级。

---

## 六、tmux 一键启动脚本（按你项目路径改）

`scripts/sessions.sh`（示例）——你可粘贴后按路径/命令修改：

```bash
#!/usr/bin/env bash
set -e

# storyapp
tmux has-session -t "proj:storyapp" 2>/dev/null || tmux new-session -d -s "proj:storyapp" -n "agent:codex-ci" "cd ~/work/storyapp && bash"
tmux rename-window -t "proj:storyapp:1" "agent:codex-ci"
tmux select-pane  -t "proj:storyapp:1.1" -T "codex:ci"

tmux new-window  -t "proj:storyapp" -n "agent:codex-ux" "cd ~/work/storyapp && bash"
tmux select-pane  -t "proj:storyapp:2.1" -T "codex:ux"

tmux new-window  -t "proj:storyapp" -n "agent:codex-voice" "cd ~/work/storyapp && bash"
tmux select-pane  -t "proj:storyapp:3.1" -T "codex:voice"

# points
tmux has-session -t "proj:points" 2>/dev/null || tmux new-session -d -s "proj:points" -n "agent:codex-ux" "cd ~/work/points && bash"
tmux select-pane  -t "proj:points:1.1" -T "codex:ux"

tmux new-window  -t "proj:points" -n "agent:codex-release" "cd ~/work/points && bash"
tmux select-pane  -t "proj:points:2.1" -T "codex:release"

# 可在对应 pane 里手动启动 codexcli，例如：
# tmux send-keys -t "proj:storyapp:agent:codex-ci.1" "codex chat --project storyapp" C-m

tmux switch-client -t "proj:storyapp" || tmux attach -t "proj:storyapp"
```

`.tmux.conf` 里建议加：

```tmux
set -g mouse on
set -g history-limit 100000
bind-key t choose-tree -Zw
bind-key M run-shell "~/tmux_sentry/scripts/sessions.sh"
```

---

## 七、对骨架代码的**两处小增强补丁**（便于你“审批→继续”）

> 这些修改可以直接粘给 codex cli 在你本地项目里改。

### 1) 解析 `### SENTRY {json}`（增强 `parse_agent_messages`）

在 `tmux_sentry/engine.py` 里，把 `parse_agent_messages` 替换为下方版本（兼容原 JSON 行与带前缀的 JSON 行）：

```python
def parse_agent_messages(text: str) -> Dict[str, Any]:
    messages: List[Dict[str, Any]] = []
    for raw in text.splitlines():
        line = raw.strip()
        if not line:
            continue
        # 1) 支持 '### SENTRY {json}'
        if line.startswith("### SENTRY"):
            payload = line[len("### SENTRY"):].strip()
            try:
                obj = json.loads(payload)
                if isinstance(obj, dict):
                    messages.append(obj)
                    continue
            except Exception:
                pass
        # 2) 纯 JSON 行
        if line.startswith("{") and line.endswith("}"):
            try:
                obj = json.loads(line)
                if isinstance(obj, dict) and obj.get("type") in {"STATUS","ASK","ACTION","LOG","ERROR"}:
                    messages.append(obj)
                    continue
            except Exception:
                pass
        # 3) Heuristic 提示
        if re.search(r"\b(error|failed|exception)\b", line, re.I):
            messages.append({"type":"ERROR","text": line})
        if re.search(r"\b(done|success|passed|completed)\b", line, re.I):
            messages.append({"type":"STATUS","status":"ok","text": line})
    return {"messages": messages}
```

### 2) 文件式审批通道（**无需 Web 服务**）

在 `tmux_sentry/engine.py` 文件顶部附近添加：

```python
APPROVAL_DIR = pathlib.Path.home()/".tmux_sentry"/"approvals"
APPROVAL_DIR.mkdir(parents=True, exist_ok=True)

def _approval_file(pane_id: str, stage: str) -> pathlib.Path:
    return APPROVAL_DIR / f"{pane_id.replace('%','pct')}__{stage}.txt"

def read_approval(pane_id: str, stage: str) -> Optional[str]:
    f = _approval_file(pane_id, stage)
    if f.exists():
        decision = f.read_text(encoding="utf-8").strip().lower()
        f.unlink(missing_ok=True)
        return decision   # 'approve' or 'reject'
    return None
```

然后在 `apply_policy(...)` 的状态机里，对 `WAIT_APPROVAL` 增加判断（示意）：

```python
elif state == "WAIT_APPROVAL":
    decision = read_approval(pane_id, stage_name)
    if decision == "approve":
        # 执行动作并进入 RUNNING
        for a in stage.get("actions_on_start", []):
            if "send_keys" in a:
                send_keys(ssh, socket, pane_id, a["send_keys"], enter=True)
                append_log(pane_id, f"[sentry] approved start {stage_name}: {a['send_keys']}")
        mem.stage_states[pane_id][stage_name] = "RUNNING"
        summary["decisions"].append({"stage":stage_name,"action":"APPROVED_START"})
    elif decision == "reject":
        mem.stage_states[pane_id][stage_name] = "FAILED"
        summary["decisions"].append({"stage":stage_name,"action":"REJECTED"})
    else:
        # 未批复，给出提示
        path_hint = str(_approval_file(pane_id, stage_name))
        summary["decisions"].append({"stage":stage_name,"action":"WAITING_APPROVAL","hint":path_hint})
```

> 效果：当某阶段 `require_approval: true` 或策略里要求 `ask_human` 时，引擎会显示一个**审批文件路径**，你只需：
>
> ```bash
> echo approve > ~/.tmux_sentry/approvals/pct12__build.txt
> # 或
> echo reject > ~/.tmux_sentry/approvals/pct12__build.txt
> ```
>
> 引擎检测到即刻继续/终止，无需额外服务。

---

## 八、你需要做的事（清单）

1. **把 zip 下载解压**，安装依赖（见上）。
2. **按本文示例**配置 `hosts.yaml`、`policies/default.yaml`；
3. **规范 tmux 命名**（或用提供的 `sessions.sh` 直接起）；
4. **在各窗口里启动 codexcli/claude**，并在首条提示中加入“`### SENTRY {json}` 输出约定”；
5. （可选）配置 **Server酱** Key 以便手机收通知；
6. 遇到审批时按提示 `echo approve/reject > 文件`。

---

## 九、后续可选增强（不影响当前使用）

* 把通知换成**企业微信机器人**（加一个 webhook 适配即可）；
* 把审批从“文件”升级为**链接点击**（一个 20 行的 FastAPI 回调就能搞定）；
* 给 `points` 增加一个 `deploy:staging` 或 `prod`，同样加 `require_approval`；
* 把阶段状态从内存换成 sqlite 文件，支持重启恢复（骨架已留好结构）。

---

## 十、最后的提示

* 你现在的规模（两项目、三五个 session）完全适合这条**极简路线 A**；
* 你**token 充足**，重点是**把日志变“机器可读”（`### SENTRY {...}`）**，调度器就能稳妥做决定；
* 真正要你参与的只有**少数审批点**和**偶发失败的 Yes/No 选择**。

---

如果你愿意，我还能把**企业微信机器人通知 + 点击审批回调**这一块补上完整代码（一个小 `FastAPI` 文件 + 一段 webhook 适配），你只需把机器人 webhook 粘进去即可用。需要的话直接说“要 WeCom 回调版”。


没问题。我已经把**企业微信机器人通知 + 点击审批回调**的完整代码补齐，并打包成一个可直接落地的项目（集成了 FastAPI 回调服务、WeCom 机器人 Markdown 消息、审批 token/HMAC 签名、链接点击→本地写入审批结果→调度器推进 的全链路）。

**下载（含完整源码）**：
[tmux\_sentry\_wecom.zip](sandbox:/mnt/data/tmux_sentry_wecom.zip)

> 这是在之前的 “tmux\_sentry” MVP 基础上，加入 **WeCom 通知** 与 **审批回调服务** 的完整版本；你只需解压、填 Webhook、起服务即可用。下面是使用方法与主要文件的代码要点。如果你要让 codex cli 实现/修改，直接把“文件清单 + 代码块”贴过去即可。

---

## 一、快速使用（NAS 上）

1. **安装依赖**

```bash
cd tmux_sentry_wecom_proj
python -m venv .venv && source .venv/bin/activate
pip install -r requirements.txt
```

2. **配置主机与策略**

```bash
cp hosts.example.yaml hosts.yaml
# 按你的 NAS / tmux 会话命名修改 hosts.yaml & policies/default.yaml
```

3. **设置环境变量（WeCom 机器人 + 回调）**

```bash
export SENTRY_NOTIFY_CHANNEL=wecom
export WECOM_WEBHOOK="https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=YOUR_KEY"
export APPROVAL_SECRET="a-strong-random-string"         # HMAC 密钥
export PUBLIC_BASE_URL="https://<你的公网或隧道域名>"      # 指向审批服务
```

> `PUBLIC_BASE_URL` 需要能从手机/企业微信访问到 NAS。最简方式用 **Cloudflare Tunnel**：
>
> ```bash
> cloudflared tunnel --url http://localhost:8787
> # 输出一个 https://*.trycloudflare.com 域名
> # 把它填进 PUBLIC_BASE_URL
> ```

4. **启动审批回调服务（FastAPI）**

```bash
bash scripts/run_server.sh
# 默认监听 http://0.0.0.0:8787
# 健康检查: curl http://127.0.0.1:8787/healthz
```

5. **运行调度器**

```bash
python -m tmux_sentry.main --config hosts.yaml --policy policies/default.yaml
```

6. **在各 tmux 窗口启动你的 codexcli/claude**，并在提示中加入约定（便于机器解析）：

> 在关键节点输出一行：`### SENTRY {json}`
> 例如：
> `### SENTRY {"type":"STATUS","stage":"build","ok":true}`
> `### SENTRY {"type":"ASK","stage":"deploy","question":"是否继续部署？"}`

当进入需要审批的阶段时，企业微信机器人会推送**带两个链接**的消息：

* **批准**：`{PUBLIC_BASE_URL}/a/<token>/approve`
* **拒绝**：`{PUBLIC_BASE_URL}/a/<token>/reject`
  点击后服务把你的选择写入本地 `~/.tmux_sentry/approvals/<pane>__<stage>.txt`，调度器下一轮就会继续执行或终止。
  （仍保留文件兜底：`echo approve > ~/.tmux_sentry/approvals/xxx__stage.txt`）

---

## 二、文件清单（关键代码已写好）

> 你可以把下面每个文件的完整内容直接交给 codex cli 写入。

### 1) `requirements.txt`

```txt
paramiko>=3.4.0
pyyaml>=6.0.2
rich>=13.7.1
textual>=0.62.0
pydantic>=2.8.2
fastapi>=0.115.0
uvicorn[standard]>=0.30.0
httpx>=0.27.0
python-dotenv>=1.0.1
```

### 2) 回调服务（FastAPI） `tmux_sentry/server.py`

```python
from __future__ import annotations
from fastapi import FastAPI, HTTPException
from fastapi.responses import HTMLResponse, PlainTextResponse
import os
from .approval import parse_token, write_decision

app = FastAPI(title="tmux_sentry approval server", version="0.1.0")

APPROVAL_SECRET = os.getenv("APPROVAL_SECRET", "CHANGE_ME")

@app.get("/healthz")
def healthz():
    return {"ok": True}

@app.get("/a/{token}/{decision}", response_class=HTMLResponse)
def approval(token: str, decision: str):
    decision = decision.lower()
    if decision not in ("approve", "reject"):
        raise HTTPException(status_code=400, detail="decision must be approve|reject")
    try:
        pane_id, stage, _ = parse_token(token, APPROVAL_SECRET)
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))
    write_decision(pane_id, stage, decision)
    return HTMLResponse(f"""
    <html><body style="font-family: sans-serif">
    <h2>✅ 已接收：{decision.upper()}</h2>
    <p>Pane: {pane_id} | Stage: {stage}</p>
    <p>调度器会在下次轮询时继续推进。</p>
    </body></html>
    """)

@app.get("/", response_class=PlainTextResponse)
def root():
    return "tmux_sentry approval server. See /healthz"
```

### 3) 审批工具集 `tmux_sentry/approval.py`

```python
from __future__ import annotations
import base64, hashlib, hmac, time, pathlib
from typing import Tuple

APPROVAL_DIR = pathlib.Path.home() / ".tmux_sentry" / "approvals"
APPROVAL_DIR.mkdir(parents=True, exist_ok=True)

def approval_file_path(pane_id: str, stage: str) -> pathlib.Path:
    return APPROVAL_DIR / f"{pane_id.replace('%','pct')}__{stage}.txt"

def write_decision(pane_id: str, stage: str, decision: str) -> None:
    f = approval_file_path(pane_id, stage)
    f.write_text(decision, encoding="utf-8")

def _b64u(data: bytes) -> str:
    import base64
    return base64.urlsafe_b64encode(data).decode("ascii").rstrip("=")

def _b64u_dec(s: str) -> bytes:
    import base64
    pad = "=" * (-len(s) % 4)
    return base64.urlsafe_b64decode(s + pad)

def make_token(pane_id: str, stage: str, secret: str, ttl_sec: int = 86400) -> str:
    ts = int(time.time())
    payload = f"{pane_id}|{stage}|{ts}|{ttl_sec}".encode("utf-8")
    sig = hmac.new(secret.encode("utf-8"), payload, hashlib.sha256).digest()
    token = _b64u(payload) + "." + _b64u(sig)
    return token

def parse_token(token: str, secret: str) -> Tuple[str, str, int]:
    payload_b64, sig_b64 = token.split(".", 1)
    payload = _b64u_dec(payload_b64)
    exp_sig = _b64u_dec(sig_b64)
    calc_sig = hmac.new(secret.encode("utf-8"), payload, hashlib.sha256).digest()
    if not hmac.compare_digest(calc_sig, exp_sig):
        raise ValueError("bad signature")
    pane_id, stage, ts_str, ttl_str = payload.decode("utf-8").split("|", 3)
    ts, ttl = int(ts_str), int(ttl_str)
    if time.time() > ts + ttl:
        raise ValueError("token expired")
    return pane_id, stage, ts

def build_links(base_url: str, token: str):
    base = base_url.rstrip("/")
    approve = f"{base}/a/{token}/approve"
    reject  = f"{base}/a/{token}/reject"
    return approve, reject
```

### 4) 通知（含企业微信机器人） `tmux_sentry/notify.py`

```python
from __future__ import annotations
import os, sys, json, urllib.request, urllib.parse
import httpx

def notify(channel: str, title: str, text: str, extra: dict | None = None):
    extra = extra or {}
    if channel == "stdout":
        print(f"[NOTIFY] {title}\n{text}")
        return

    if channel == "serverchan":
        key = os.getenv("SENTRY_SERVERCHAN_KEY","")
        if not key:
            print("[WARN] SERVERCHAN KEY missing", file=sys.stderr); return
        url = f"https://sctapi.ftqq.com/{key}.send"
        data = urllib.parse.urlencode({"title": title, "desp": text}).encode("utf-8")
        try:
            urllib.request.urlopen(url, data=data, timeout=5)
        except Exception as e:
            print(f"[WARN] serverchan notify failed: {e}", file=sys.stderr)
        return

    if channel == "wecom":
        webhook = os.getenv("WECOM_WEBHOOK", "").strip()
        if not webhook:
            print("[WARN] WECOM_WEBHOOK missing", file=sys.stderr); return
        content = f"**{title}**\\n\\n{text}"
        payload = {"msgtype": "markdown", "markdown": {"content": content}}
        try:
            with httpx.Client(timeout=5.0) as client:
                r = client.post(webhook, json=payload)
                r.raise_for_status()
        except Exception as e:
            print(f"[WARN] wecom notify failed: {e}", file=sys.stderr)
        return

    print(f"[WARN] Unknown channel: {channel}", file=sys.stderr)
```

### 5) 引擎（支持 `ask_human`、`require_approval`） `tmux_sentry/engine.py`

（已完整实现，见压缩包；关键点是进入 `WAIT_APPROVAL` 时返回 `{"action":"ASK_HUMAN"}` 或 `{"action":"WAITING_APPROVAL"}`，由 `main.py` 发送 WeCom 链接）

### 6) 主循环（生成审批链接并发送 WeCom） `tmux_sentry/main.py`

（已完整实现；核心逻辑：检测到 WAITING\_APPROVAL → `make_token` → 生成 `[批准](...) / [拒绝](...)` 链接 → `notify(wecom, ...)`，同时写入一个 `.sent` 标记文件，避免重复刷屏）

### 7) 启动脚本 `scripts/run_server.sh`

```bash
#!/usr/bin/env bash
set -e
export UVICORN_WORKERS=${UVICORN_WORKERS:-1}
uvicorn tmux_sentry.server:app --host 0.0.0.0 --port 8787 --workers $UVICORN_WORKERS
```

---

## 三、codex/claude 的提示模板（贴给你的智能体）

> 你是一个会在 tmux pane 中运行的代码智能体。除正常输出外，当你完成一个阶段或需要人类批准/决策时，额外输出一行：
> `### SENTRY {json}`
> 其中 `json` 包含：
>
> * 成功：`{"type":"STATUS","stage":"<stage>","ok":true,"summary":"..."}`
> * 失败：`{"type":"ERROR","stage":"<stage>","detail":"..."}`
> * 询问：`{"type":"ASK","stage":"<stage>","question":"...", "options":["approve","reject"]}`
>   其他输出保持自然语言即可。

---

## 四、验证 Checklist

* [ ] `curl http://127.0.0.1:8787/healthz` 返回 `{"ok":true}`
* [ ] `PUBLIC_BASE_URL` 能在手机上访问（用 Cloudflare Tunnel/Tailscale Funnel/FRP 任一）
* [ ] WeCom 机器人能收到 Markdown 消息，链接可点开并显示“✅ 已接收 …”
* [ ] 点击后，NAS 上出现 `~/.tmux_sentry/approvals/<pane>__<stage>.txt`，内容为 `approve`/`reject`
* [ ] 调度器在下一轮推进或停止，日志记入 `~/.tmux_sentry/logs/…`

---

## 五、你需要做的事（最少）

1. 在企业微信里创建一个**群机器人**，拿到 `WECOM_WEBHOOK`。
2. 在 NAS 上**起回调服务**（`scripts/run_server.sh`）。
3. 用 **Cloudflare Tunnel** 或其他方式把 `8787` 暴露出去，设置 `PUBLIC_BASE_URL`。
4. 给 `codexcli/claude` 加上 `### SENTRY {json}` 输出约定。
5. 跑 `python -m tmux_sentry.main ...`，其余交给调度器。

---

需要我**把 Cloudflare Tunnel（或 Tailscale Funnel）的一键脚本**也补上吗？或者你确定用哪种暴露方式，我就给出对应最简单的安装与开机常驻脚本。

# 企业微信机器人的相关信息和凭证

agentid:   1000002
secret:
```
eu-BbKawabreQTJPeacL63jVYllSJILrDVMHIjiTs2A
```
Company ID

ww963453c57ce43b45

# 微信机器人的使用：

先提醒一下安全性：你已经把 **Secret** 发出来了，这等同于泄露。**请立刻到 企业微信后台 → 应用管理 → 你的自建应用 → 重置 Secret**，然后在下面脚本/CI 里用新的 Secret。不要把密钥写进仓库或聊天记录里，统一放到环境变量或 `.env`，文件权限设为 600。

---

下面给你一套**即用型 Bash 脚本**（自动获取并缓存 `access_token`，失效自动刷新），支持 `.env` 与环境变量两种配置。

### 1) 保存为 `wecom_push.sh`

```bash
#!/usr/bin/env bash
set -euo pipefail

# ========== 配置 ==========
# 优先读环境变量，其次读 .env 文件
ENV_FILE="${ENV_FILE:-.env}"
if [[ -f "$ENV_FILE" ]]; then
  # shellcheck disable=SC2046
  export $(grep -E '^(WECOM_CORP_ID|WECOM_AGENT_ID|WECOM_SECRET|WECOM_TOUSER)=' "$ENV_FILE" | xargs -d '\n')
fi

: "${WECOM_CORP_ID:?请设置 WECOM_CORP_ID}"
: "${WECOM_AGENT_ID:?请设置 WECOM_AGENT_ID}"
: "${WECOM_SECRET:?请设置 WECOM_SECRET}"
WECOM_TOUSER="${WECOM_TOUSER:-@all}"    # 也可填写具体用户ID，用竖线分隔：zhangsan|lisi

CACHE_DIR="${HOME}/.cache/wecom"
mkdir -p "$CACHE_DIR"
TOKEN_CACHE="${CACHE_DIR}/token_${WECOM_CORP_ID}_${WECOM_AGENT_ID}.json"

has_jq() { command -v jq >/dev/null 2>&1; }

get_token() {
  # 若缓存可用且未过期（预留 300s 余量），直接用
  if [[ -f "$TOKEN_CACHE" ]]; then
    if has_jq; then
      local now exp
      now=$(date +%s)
      exp=$(jq -r '.expires_at // 0' "$TOKEN_CACHE")
      if [[ "$now" -lt "$exp" ]]; then
        jq -r '.access_token' "$TOKEN_CACHE"
        return 0
      fi
    fi
  fi

  # 拉取新 token
  resp="$(curl -sS "https://qyapi.weixin.qq.com/cgi-bin/gettoken?corpid=${WECOM_CORP_ID}&corpsecret=${WECOM_SECRET}")"
  if has_jq; then
    err="$(jq -r '.errcode' <<<"$resp")"
    [[ "$err" == "0" ]] || { echo "获取token失败: $resp" >&2; exit 1; }
    token="$(jq -r '.access_token' <<<"$resp")"
    ttl="$(jq -r '.expires_in' <<<"$resp")"
    now="$(date +%s)"
    exp=$((now + ttl - 300))
    printf '{"access_token":"%s","expires_at":%d}\n' "$token" "$exp" > "$TOKEN_CACHE"
    echo "$token"
  else
    # 无 jq 的简易解析（建议安装 jq）
    token="$(echo "$resp" | grep -o '"access_token":"[^"]\+' | cut -d'"' -f4 || true)"
    ttl="$(echo "$resp"   | grep -o '"expires_in":[0-9]\+' | cut -d: -f2 || echo 7200)"
    [[ -n "$token" ]] || { echo "获取token失败(建议安装 jq): $resp" >&2; exit 1; }
    now="$(date +%s)"; exp=$((now + ttl - 300))
    printf '{"access_token":"%s","expires_at":%d}\n' "$token" "$exp" > "$TOKEN_CACHE"
    echo "$token"
  fi
}

send_text() {
  local content="$1"
  local token
  token="$(get_token)"
  curl -sS "https://qyapi.weixin.qq.com/cgi-bin/message/send?access_token=${token}" \
    -H 'Content-Type: application/json' \
    -d "$(cat <<JSON
{
  "touser": "${WECOM_TOUSER}",
  "msgtype": "text",
  "agentid": ${WECOM_AGENT_ID},
  "text": {"content": "$(echo "$content" | sed 's/"/\\"/g')"},
  "safe": 0
}
JSON
)"
}

send_markdown() {
  local md="$1"
  local token
  token="$(get_token)"
  curl -sS "https://qyapi.weixin.qq.com/cgi-bin/message/send?access_token=${token}" \
    -H 'Content-Type: application/json' \
    -d "$(cat <<JSON
{
  "touser": "${WECOM_TOUSER}",
  "msgtype": "markdown",
  "agentid": ${WECOM_AGENT_ID},
  "markdown": {"content": "$(echo "$md" | sed 's/"/\\"/g')"}
}
JSON
)"
}

usage() {
  cat <<'USAGE'
用法:
  ./wecom_push.sh text "纯文本内容"
  ./wecom_push.sh md   "Markdown 内容"

环境变量/或 .env 支持:
  WECOM_CORP_ID   企业ID (CorpID)
  WECOM_AGENT_ID  应用ID (AgentId)
  WECOM_SECRET    应用Secret
  WECOM_TOUSER    接收人(默认 @all，可用 zhang|li 分隔)

示例:
  ./wecom_push.sh text "部署完成 ✅"
  ./wecom_push.sh md   "**构建成功**\n> 版本: v1.2.3\n> 用时: 128s ✅"
USAGE
}

cmd="${1:-}"; shift || true
case "$cmd" in
  text) [[ $# -ge 1 ]] || { usage; exit 1; }; send_text "$*";;
  md)   [[ $# -ge 1 ]] || { usage; exit 1; }; send_markdown "$*";;
  *)    usage; exit 1;;
esac
```

### 2) 准备 `.env`（文件权限务必 600）

```bash
# .env
WECOM_CORP_ID=ww963453c57ce43b45
WECOM_AGENT_ID=1000002
WECOM_SECRET=替换为你重置后的新Secret
# WECOM_TOUSER=@all
```

```bash
chmod 600 .env
chmod +x wecom_push.sh
```

### 3) 发送测试

```bash
./wecom_push.sh text "测试推送 ✅ 来自脚本"
./wecom_push.sh md   "**CI完成**\n> 镜像: ghcr.io/xxx:build-42\n> 状态: 成功 ✅"
```

---

## 在 GitHub Actions 里用

把三项放到仓库 **Secrets**（如：`WECOM_CORP_ID` / `WECOM_AGENT_ID` / `WECOM_SECRET`），示例步骤：

```yaml
- name: Notify WeCom
  run: |
    cat > wecom_push_ci.sh <<'BASH'
    #!/usr/bin/env bash
    set -euo pipefail
    token=$(curl -sS "https://qyapi.weixin.qq.com/cgi-bin/gettoken?corpid=$WECOM_CORP_ID&corpsecret=$WECOM_SECRET" | jq -r '.access_token')
    curl -sS "https://qyapi.weixin.qq.com/cgi-bin/message/send?access_token=$token" \
      -H 'Content-Type: application/json' \
      -d "{
        \"touser\":\"@all\",
        \"msgtype\":\"markdown\",
        \"agentid\":$WECOM_AGENT_ID,
        \"markdown\":{\"content\":\"**部署完成**\\n> 环境: prod\\n> 提交: $GITHUB_SHA ✅\"}
      }"
    BASH
    chmod +x wecom_push_ci.sh
    ./wecom_push_ci.sh
  env:
    WECOM_CORP_ID: ${{ secrets.WECOM_CORP_ID }}
    WECOM_AGENT_ID: ${{ secrets.WECOM_AGENT_ID }}
    WECOM_SECRET: ${{ secrets.WECOM_SECRET }}
```

---

## 安全与实用建议

* **立刻重置 Secret**（你刚发出来的那条当作已泄露）。
* `.env` 不进仓库：在 `.gitignore` 里忽略它；或改用环境变量注入。
* 脚本里的 `@all` 可改成指定成员 `user1|user2` 以免打扰全员。
* 生产机上建议安装 `jq` 提升稳定性：`apt/yum install jq`。

需要我把这个脚本改成一个**简易 HTTP 服务**（`docker-compose` 一键起，POST `/send` 就能推）吗？这样你在 CI、NAS 上调用会更像 Server酱的用法。
